<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Big Data Digital City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- A-Frame et extras -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://unpkg.com/aframe-reflection-component@^1.0.0/dist/aframe-reflection-component.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.loaders.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
  </style>
</head>
<body>

<!-- Audio immersif futuriste -->
<audio autoplay loop>
  <source src="https://cdn.pixabay.com/audio/2023/03/07/audio_eb50a9b332.mp3" type="audio/mpeg">
</audio>

<a-scene background="color: #000">

  <!-- Caméra avec déplacement infini -->
  <a-entity id="cameraRig" position="0 3 100" rotation="-8 0 0" move-forward="speed: 1">
    <a-entity camera look-controls="enabled: false"></a-entity>
  </a-entity>

  <!-- Lumières -->
  <a-entity light="type: ambient; color: #88ffff; intensity: 0.6"></a-entity>
  <a-entity light="type: directional; color: #00ffff; intensity: 0.8" position="0 10 10"></a-entity>

  <!-- Sol avec effet eau animé -->
  <a-water
    position="0 0 0"
    rotation="-90 0 0"
    width="1000"
    height="1000"
    color="#001e0f"
    distortionFactor="0.1"
    flowDirection="1 0">
  </a-water>

  <!-- Bâtiments avec code binaire animé sur toutes les faces -->
  <a-entity id="city" generate-city></a-entity>

  <script>
    // Composant déplacement continu vers l'avant
    AFRAME.registerComponent('move-forward', {
      schema: { speed: {type: 'number', default: 0.5} },
      tick: function (time, delta) {
        const position = this.el.getAttribute('position');
        position.z -= this.data.speed * (delta / 1000);
        this.el.setAttribute('position', position);
      }
    });

    AFRAME.registerComponent('generate-city', {
      init: function () {
        const container = this.el;
        const spacing = 5; // bâtiment plus proche

        for (let x = -40; x <= 40; x += spacing) {
          for (let z = -40; z >= -400; z -= spacing) {
            const h = Math.random() * 10 + 3;

            const building = document.createElement('a-entity');
            building.setAttribute('position', `${x} 0 ${z}`);

            const box = document.createElement('a-box');
            box.setAttribute('position', `0 ${h/2} 0`);
            box.setAttribute('width', '4');
            box.setAttribute('depth', '4');
            box.setAttribute('height', h.toFixed(2));
            box.setAttribute('color', '#00ffff');
            box.setAttribute('opacity', '0.6');
            building.appendChild(box);

            const faces = [
              { pos: '0 ' + h / 2 + ' 2.01', rot: '0 0 0' },
              { pos: '0 ' + h / 2 + ' -2.01', rot: '0 180 0' },
              { pos: '2.01 ' + h / 2 + ' 0', rot: '0 -90 0' },
              { pos: '-2.01 ' + h / 2 + ' 0', rot: '0 90 0' }
            ];

            faces.forEach(face => {
              const binaryPlane = document.createElement('a-plane');
              binaryPlane.setAttribute('position', face.pos);
              binaryPlane.setAttribute('rotation', face.rot);
              binaryPlane.setAttribute('width', '4');
              binaryPlane.setAttribute('height', h.toFixed(2));
              binaryPlane.setAttribute('material', 'shader: flat; side: double;');

              const canvas = document.createElement('canvas');
              canvas.width = 256;
              canvas.height = 512;
              const ctx = canvas.getContext('2d');
              const chars = 'アカサタナハマヤラワ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
              const columns = canvas.width / 10;
              const drops = Array(Math.floor(columns)).fill(1);

              function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ffff';
                ctx.font = '10px monospace';
                for (let i = 0; i < drops.length; i++) {
                  const text = chars[Math.floor(Math.random() * chars.length)];
                  ctx.fillText(text, i * 10, drops[i] * 10);
                  drops[i]++;
                  if (drops[i] * 10 > canvas.height || Math.random() > 0.975) {
                    drops[i] = 0;
                  }
                }
              }

              const texture = new THREE.CanvasTexture(canvas);
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(1, 1);
              setInterval(() => {
                drawMatrix();
                texture.needsUpdate = true;
              }, 50);

              binaryPlane.addEventListener('loaded', () => {
                binaryPlane.getObject3D('mesh').material.map = texture;
                binaryPlane.getObject3D('mesh').material.needsUpdate = true;
              });

              building.appendChild(binaryPlane);
            });

            container.appendChild(building);
          }
        }
      }
    });
  </script>

</a-scene>

</body>
</html>
