<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Handball Ultra Trajectoire</title>
  <meta name="description" content="Handball VR/PC/mobile : attrape, trace et lance la balle avec une trajectoire comme dans FIFA corner.">
  <link href="https://fonts.googleapis.com/css?family=Kameron:700|Orbitron:900|Montserrat:400,700&display=swap" rel="stylesheet">
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@5.0.0/dist/aframe-physics-system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-animation-component@6.0.0/dist/aframe-animation-component.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.0.0/dist/aframe-extras.controls.min.js"></script>
  <style>
    body { margin:0; background:radial-gradient(ellipse at 50% 30%, #e5f6ff 40%, #b3d0ee 100%); font-family:'Montserrat',Arial,sans-serif; }
    .handball-overlay {
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:10000;
      display:flex;align-items:center;justify-content:center;
      background:rgba(0,23,50,0.88);
      flex-direction:column;
      animation:fadeIn 1.4s;
    }
    @keyframes fadeIn { from {opacity:0;} to {opacity:1;} }
    .handball-btn {
      font-family:'Orbitron',Arial,sans-serif; font-size:2.1rem; text-transform:uppercase; letter-spacing:0.07em;
      padding:1.1em 2.6em; border-radius:1.4em;
      background:linear-gradient(90deg, #1e90ff 0%, #30c6fb 100%);
      color:#fff; border:none; box-shadow:0 4px 32px #1497ff55, 0 1px 0 #063a5b;
      cursor:pointer; transition:background 0.22s,transform 0.18s, box-shadow 0.22s;
      outline:none;
    }
    .handball-btn:hover {
      background:linear-gradient(90deg, #155fa0 0%, #1497ff 100%);
      transform:scale(1.06); box-shadow:0 8px 38px #30c6fb44, 0 0px 0 #063a5b;
    }
    .handball-title {
      font-family:'Orbitron',Arial,sans-serif;font-size:3.3rem;color:#fff;
      text-shadow:0 6px 32px #1497ff55, 0 2px 12px #063a5b;letter-spacing:0.09em;
      margin-bottom:1.6rem;margin-top:-2rem;text-align:center;
      background: linear-gradient(90deg,#1e90ff,#30c6fb 65%,#fff 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .handball-desc {
      color:#e5f6ff; font-size:1.25em; margin-top:1.3rem; margin-bottom:0.7rem;
      text-align:center; text-shadow:0 2px 10px #0009; letter-spacing:0.04em; max-width:700px;
    }
    @media (max-width:700px) { .handball-title {font-size:2.1rem;} .handball-desc {font-size:1em;} }
  </style>
</head>
<body>
<div id="handballOverlay" class="handball-overlay">
  <div class="handball-title">Handball Ultra Trajectoire</div>
  <button class="handball-btn" id="startBtn">Jouer</button>
  <div class="handball-desc">Sur PC/mobile, clique ou touche la balle, trace ta trajectoire, relâche pour tirer.<br>
    Un trait bleu te montre la direction !
  </div>
</div>
<a-scene physics="gravity:-9.8;" loading-screen="enabled:false" id="scene">
  <a-assets>
    <a-asset-item id="handball-ball" src="handball_1964/scene.gltf"></a-asset-item>
  </a-assets>
  <!-- Terrain de handball, aligné avec la balle -->
  <a-plane width="20" height="40" color="#eab676" position="-0.22558 0 0" rotation="-90 0 0"></a-plane>
  <!-- Ballon handball interactif -->
  <a-entity id="handball"
    gltf-model="#handball-ball"
    position="-0.22558 1 0.8"
    scale="0.009 0.009 0.009"
    dynamic-body="mass: 0.36; restitution:0.81; friction:0.33"
    ball-trajectory
    shadow
    obb-collider="centerModel: true"></a-entity>
  <!-- Camera -->
  <a-entity id="rig" position="0.60286 1.7 0">
    <a-entity id="camera" camera look-controls wasd-controls></a-entity>
  </a-entity>
</a-scene>
<script>
document.getElementById('startBtn').onclick = function() {
  document.getElementById('handballOverlay').style.display = 'none';
};

// Composant fiable pour drag/trajectoire sur PC/mobile
AFRAME.registerComponent('ball-trajectory', {
  schema: { lineColor: {default: "#1e90ff"} },
  init: function () {
    this.dragging = false;
    this.positions = [];
    this.line = null;
    this.scene = this.el.sceneEl;
    this.startPos = null;
    this.pointerId = null;
    // Raycast sur la scène pour détecter le clic/touch sur la balle
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.scene.addEventListener('mousedown', this.onPointerDown);
    this.scene.addEventListener('touchstart', this.onPointerDown);
    window.addEventListener('mousemove', this.onPointerMove);
    window.addEventListener('touchmove', this.onPointerMove, {passive:false});
    window.addEventListener('mouseup', this.onPointerUp);
    window.addEventListener('touchend', this.onPointerUp);
  },
  remove: function () {
    this.scene.removeEventListener('mousedown', this.onPointerDown);
    this.scene.removeEventListener('touchstart', this.onPointerDown);
    window.removeEventListener('mousemove', this.onPointerMove);
    window.removeEventListener('touchmove', this.onPointerMove);
    window.removeEventListener('mouseup', this.onPointerUp);
    window.removeEventListener('touchend', this.onPointerUp);
  },
  onPointerDown: function(e) {
    let x, y;
    if(e.type.startsWith('touch')) {
      x = e.touches[0].clientX; y = e.touches[0].clientY; this.pointerId = e.touches[0].identifier;
    } else { x = e.clientX; y = e.clientY; }
    // Raycast pour check si balle sous le pointer
    const scene = this.scene;
    const camera = scene.camera;
    const mouse = new THREE.Vector2((x / window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const mesh = this.el.getObject3D('mesh');
    if(!mesh) return;
    const intersects = raycaster.intersectObject(mesh,true);
    if(!intersects.length) return;
    // Désactive le drag caméra
    if (scene.components['look-controls']) scene.components['look-controls'].pause();
    e.preventDefault();
    this.dragging = true;
    this.positions = [];
    this.startPos = this.getWorldPos();
    this.positions.push(this.startPos.clone());
    this.addLine();
  },
  onPointerMove: function(e) {
    if(!this.dragging) return;
    let x, y;
    if(e.type.startsWith('touch')){
      let found = false;
      for(let i=0; i<e.touches.length; i++) {
        if(e.touches[i].identifier == this.pointerId) {
          x = e.touches[i].clientX; y = e.touches[i].clientY; found=true; break;
        }
      }
      if(!found) return;
    } else { x = e.clientX; y = e.clientY; }
    const pos = this.screenToWorld(x, y);
    if(pos) {
      this.positions.push(pos.clone());
      this.updateLine();
    }
    if(e.type.startsWith('touch')) e.preventDefault();
  },
  onPointerUp: function(e) {
    if(!this.dragging) return;
    this.dragging = false;
    // Restaure drag caméra
    if(this.scene.components['look-controls']) this.scene.components['look-controls'].play();
    if(this.positions.length > 2) this.launchBall();
    this.removeLine();
    this.positions = [];
    this.pointerId = null;
  },
  getWorldPos: function () {
    const pos = new THREE.Vector3();
    this.el.object3D.getWorldPosition(pos);
    return pos;
  },
  screenToWorld: function (x, y) {
    const scene = this.scene;
    const camera = scene.camera;
    const mouse = new THREE.Vector2((x / window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const planeY = 1; // hauteur de la balle
    const origin = raycaster.ray.origin, dir = raycaster.ray.direction;
    if (Math.abs(dir.y) < 1e-4) return null;
    const t = (planeY - origin.y) / dir.y;
    if (t < 0) return null;
    return origin.clone().add(dir.clone().multiplyScalar(t));
  },
  addLine: function () {
    if(!this.line) {
      this.line = document.createElement('a-entity');
      this.line.setAttribute('line', {
        color: this.data.lineColor, opacity: 0.8, start: '0 0 0', end: '0 0 0'
      });
      this.scene.appendChild(this.line);
    }
  },
  updateLine: function () {
    if(!this.line || this.positions.length < 2) return;
    const start = this.positions[0], end = this.positions[this.positions.length-1];
    this.line.setAttribute('line', {
      color: this.data.lineColor, opacity: 0.8,
      start: `${start.x} ${start.y} ${start.z}`,
      end:   `${end.x} ${end.y} ${end.z}`
    });
  },
  removeLine: function () { this.line && this.line.parentNode.removeChild(this.line); this.line = null; },
  launchBall: function () {
    const start = this.positions[0], end = this.positions[this.positions.length-1];
    const dir = new THREE.Vector3().subVectors(end, start);
    const force = dir.clone().multiplyScalar(6);
    if(this.el.body) {
      this.el.body.velocity.set(0,0,0); this.el.body.angularVelocity.set(0,0,0);
      this.el.body.applyImpulse(new CANNON.Vec3(force.x, force.y, force.z), new CANNON.Vec3(0,0,0));
    }
  }
});
</script>
</body>
</html>
