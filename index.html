<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Big Data Digital City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; font-family: Arial, sans-serif; }
    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; color: #00ffff; display: flex; justify-content: center; align-items: center;
      z-index: 1000; font-size: 24px;
    }
    #controls {
      position: fixed; top: 20px; left: 20px; color: #00ffff;
      background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100; font-size: 14px;
    }
  </style>
</head>
<body>

<div id="loading">Chargement de la ville num√©rique...</div>

<div id="controls">
  <div>üéÆ WASD - Se d√©placer</div>
  <div>üñ±Ô∏è Souris - Regarder autour</div>
  <div>üì± Mobile - Touch controls</div>
</div>

<a-scene loading-screen="enabled: false">

  <!-- Skybox -->
  <a-sky color="#000011" material="shader: gradient; topColor: #000033; bottomColor: #000000"></a-sky>
  
  <!-- Cam√©ra bien d√©gag√©e au centre -->
  <a-entity id="cameraRig" position="0 1.5 0">
    <a-entity
      camera
      look-controls="pointerLockEnabled: true"
      wasd-controls="acceleration: 20; fly: true"
      position="0 0 0">
    </a-entity>
  </a-entity>

  <!-- Lumi√®res -->
  <a-entity light="type: ambient; color: #002244; intensity: 0.4"></a-entity>
  <a-entity light="type: directional; color: #00ffff; intensity: 0.8" position="20 30 20"></a-entity>
  <a-entity light="type: point; color: #ff0066; intensity: 0.5" position="-20 15 -20"></a-entity>

  <!-- Sol -->
  <a-plane
    position="0 0 0"
    rotation="-90 0 0"
    width="300"
    height="300"
    color="#000000"
    material="metalness: 0.9; roughness: 0.1; emissive: #001122; emissiveIntensity: 0.2"
    shadow="receive: true">
  </a-plane>

  <!-- Grille -->
  <a-entity id="grid" generate-grid></a-entity>

  <!-- Ville -->
  <a-entity id="city" generate-city></a-entity>

  <!-- Particules -->
  <a-entity particle-system="preset: dust; particleCount: 150; color: #00ffff,#ff0066; size: 0.3; accelerationValue: 0 0.1 0"></a-entity>

  <script>
    // Grille cyberpunk
    AFRAME.registerComponent('generate-grid', {
      init: function () {
        const container = this.el;
        const gridSize = 150;
        const spacing = 10;
        for (let i = -gridSize; i <= gridSize; i += spacing) {
          const line = document.createElement('a-entity');
          line.setAttribute('geometry', { primitive: 'box', width: gridSize * 2, height: 0.05, depth: 0.1 });
          line.setAttribute('position', `0 0.01 ${i}`);
          line.setAttribute('material', { color: '#00ffff', emissive: '#00ffff', emissiveIntensity: 0.3, opacity: 0.4, transparent: true });
          container.appendChild(line);
        }
        for (let i = -gridSize; i <= gridSize; i += spacing) {
          const line = document.createElement('a-entity');
          line.setAttribute('geometry', { primitive: 'box', width: 0.1, height: 0.05, depth: gridSize * 2 });
          line.setAttribute('position', `${i} 0.01 0`);
          line.setAttribute('material', { color: '#00ffff', emissive: '#00ffff', emissiveIntensity: 0.3, opacity: 0.4, transparent: true });
          container.appendChild(line);
        }
      }
    });

    // Loading
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('controls').style.opacity = '1';
      }, 2000);
    });

    // Ville dense, buildings g√©ants, tailles vari√©es, zone centrale vide
    AFRAME.registerComponent('generate-city', {
      init: function () {
        const container = this.el;
        const spacing = 4.2; // serr√© mais pas coll√©
        const gridSize = 18;
        const emptyRadius = 6; // zone centrale VIDE pour spawn

        // Texture Matrix anim√©e adapt√©e √† la taille du panneau
        function createMatrixTextureAnim(widthPx, heightPx, colorBase, animationDuration) {
          const canvas = document.createElement('canvas');
          canvas.width = widthPx;
          canvas.height = heightPx;
          const ctx = canvas.getContext('2d');
          const chars = '„Ç¢„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É©„ÉØ0123456789ABCDEF';
          const fontSize = 8;
          // Calcul dynamique du nombre de colonnes/rows
          const columns = Math.floor(canvas.width / fontSize);
          const rows = Math.floor(canvas.height / fontSize);
          let drops = Array(columns).fill( Math.floor(Math.random() * rows) );

          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);

          function animateMatrix() {
            // Variation couleur synchronis√©e, mais animation matrix fluide
            const phase = (Date.now() / animationDuration) % 1;
            const intensity = 0.7 + Math.sin(phase * Math.PI * 2) * 0.3;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.16)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${fontSize}px monospace`;
            for (let i = 0; i < columns; i++) {
              const char = chars[Math.floor(Math.random() * chars.length)];
              let r = 0, g = Math.floor(255 * intensity), b = Math.floor(200 * colorBase);
              ctx.fillStyle = `rgba(${r},${g},${b},${0.83 + Math.random()*0.17})`;
              ctx.fillText(char, i * fontSize, drops[i] * fontSize);

              if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
              }
              drops[i] += 1 + phase * 1.5;
            }
            texture.needsUpdate = true;
            requestAnimationFrame(animateMatrix);
          }
          animateMatrix();
          return texture;
        }

        let buildingIndex = 0;
        for (let x = -gridSize; x <= gridSize; x += 2) {
          for (let z = -gridSize; z <= gridSize; z += 2) {
            // Zone centrale vide pour le joueur (aucun bat autour du (0,0))
            if (Math.abs(x) <= emptyRadius && Math.abs(z) <= emptyRadius) continue;

            // Taille variable
            const width = 1.9 + Math.random() * 3.1;   // 1.9 √† 5
            const depth = 1.9 + Math.random() * 3.1;
            const height = 24 + Math.random() * 120;   // 24 √† 144
            const posX = x * spacing;
            const posZ = z * spacing;
            const buildingId = `building_${x}_${z}`;
            const animationDuration = 6000 + Math.random() * 4000;
            const colorBase = 0.7 + Math.random() * 0.3;

            this.createBuilding(container, posX, posZ, width, depth, height, colorBase, buildingId, animationDuration, createMatrixTextureAnim);
            buildingIndex++;
          }
        }
      },

      createBuilding: function(container, x, z, width, depth, height, colorBase, id, animationDuration, createMatrixTextureAnim) {
        const building = document.createElement('a-entity');
        building.setAttribute('id', id);
        building.setAttribute('position', `${x} 0 ${z}`);

        // Structure principale (base au sol)
        const mainBox = document.createElement('a-box');
        mainBox.setAttribute('width', width.toFixed(2));
        mainBox.setAttribute('depth', depth.toFixed(2));
        mainBox.setAttribute('height', height.toFixed(2));
        mainBox.setAttribute('position', `0 ${height/2} 0`);
        mainBox.setAttribute('material', {
          color: '#00ffff',
          opacity: 0.54,
          transparent: true,
          emissive: '#002244',
          emissiveIntensity: 0.32,
          metalness: 0.7,
          roughness: 0.3
        });
        mainBox.setAttribute('shadow', 'cast: true; receive: true');
        // Animation verticale synchronis√©e
        mainBox.setAttribute('animation__float', {
          property: 'position',
          to: `0 ${height/2} 0`,
          from: `0 ${height/2 - 3} 0`,
          dir: 'alternate',
          dur: animationDuration,
          loop: true,
          easing: 'easeInOutSine'
        });
        building.appendChild(mainBox);

        // Pour chaque face, Matrix "plein", adapt√© √† la taille (pas d'√©tirement)
        const faces = [
          { pos: [0, height/2, depth/2 + 0.06], rot: [0, 0, 0], w: width, h: height },
          { pos: [0, height/2, -depth/2 - 0.06], rot: [0, 180, 0], w: width, h: height },
          { pos: [width/2 + 0.06, height/2, 0], rot: [0, -90, 0], w: depth, h: height },
          { pos: [-width/2 - 0.06, height/2, 0], rot: [0, 90, 0], w: depth, h: height }
        ];
        faces.forEach((face, index) => {
          const panel = document.createElement('a-plane');
          panel.setAttribute('width', face.w.toFixed(2));
          panel.setAttribute('height', face.h.toFixed(2));
          panel.setAttribute('position', `${face.pos[0]} ${face.pos[1]} ${face.pos[2]}`);
          panel.setAttribute('rotation', `${face.rot[0]} ${face.rot[1]} ${face.rot[2]}`);
          panel.setAttribute('material', {
            shader: 'flat',
            side: 'double',
            transparent: true,
            opacity: 0.89
          });
          // Animation synchronis√©e
          panel.setAttribute('animation__float', {
            property: 'position',
            to: `${face.pos[0]} ${face.pos[1]} ${face.pos[2]}`,
            from: `${face.pos[0]} ${face.pos[1] - 3} ${face.pos[2]}`,
            dir: 'alternate',
            dur: animationDuration,
            loop: true,
            easing: 'easeInOutSine'
          });
          // Texture Matrix anim√©e, adapt√©e √† la taille exacte du panneau
          panel.addEventListener('loaded', () => {
            // 32px par unit√© pour une tr√®s bonne r√©solution sur les hautes fa√ßades
            const texWidth = Math.ceil(face.w * 32);
            const texHeight = Math.ceil(face.h * 32);
            const texture = createMatrixTextureAnim(texWidth, texHeight, colorBase, animationDuration);
            const mesh = panel.getObject3D('mesh');
            if (mesh && mesh.material) {
              mesh.material.map = texture;
              mesh.material.needsUpdate = true;
            }
          });
          building.appendChild(panel);
        });

        // Antenne sur le toit
        if (Math.random() > 0.7) {
          const antenna = document.createElement('a-cylinder');
          antenna.setAttribute('radius', '0.13');
          antenna.setAttribute('height', '5');
          antenna.setAttribute('position', `0 ${height + 2.5} 0`);
          antenna.setAttribute('color', '#ff0066');
          antenna.setAttribute('material', 'emissive: #ff0066; emissiveIntensity: 0.5');
          antenna.setAttribute('animation__float', {
            property: 'position',
            to: `0 ${height + 2.5} 0`,
            from: `0 ${height + 2.5 - 3} 0`,
            dir: 'alternate',
            dur: animationDuration,
            loop: true,
            easing: 'easeInOutSine'
          });
          building.appendChild(antenna);
        }
        container.appendChild(building);
      }
    });

    // Shader d√©grad√© ciel
    AFRAME.registerShader('gradient', {
      schema: { topColor: {type: 'color', default: '#000033'}, bottomColor: {type: 'color', default: '#000000'} },
      vertexShader: `
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}
      `,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        varying vec2 vUv;
        void main() { gl_FragColor = vec4(mix(bottomColor, topColor, vUv.y), 1.0);}
      `
    });

    // Performances
    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', function () {
      scene.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      scene.renderer.shadowMap.enabled = true;
      scene.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    });
    window.addEventListener('resize', function() {
      const scene = document.querySelector('a-scene');
      if (scene.renderer) {
        scene.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>

</a-scene>
</body>
</html>
