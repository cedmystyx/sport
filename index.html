<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Big Data Digital City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <style> body { margin: 0; overflow: hidden; background: black; } </style>
</head>
<body>

<!-- Son futuriste -->
<audio autoplay loop>
  <source src="https://cdn.pixabay.com/audio/2023/03/07/audio_eb50a9b332.mp3" type="audio/mpeg">
</audio>

<a-scene background="color: #000">

  <!-- Caméra centrale immersive -->
  <a-entity position="0 5 0">
    <a-entity camera look-controls wasd-controls="enabled: false"></a-entity>
  </a-entity>

  <!-- Lumières -->
  <a-entity light="type: ambient; color: #88ffff; intensity: 0.5"></a-entity>
  <a-entity light="type: directional; color: #00ffff; intensity: 0.7" position="10 20 10"></a-entity>

  <!-- Ville dynamique -->
  <a-entity id="city" generate-city></a-entity>

  <script>
    AFRAME.registerComponent('generate-city', {
      init: function () {
        const container = this.el;
        const spacing = 10; // espacement augmenté
        const size = 60;

        // Génération de la texture "Matrix"
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const chars = 'アカサタナ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const columns = canvas.width / 10;
        const drops = Array(Math.floor(columns)).fill(1);

        function drawMatrix() {
          ctx.fillStyle = 'rgba(0,0,0,0.05)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#00ffff';
          ctx.font = '10px monospace';
          for (let i = 0; i < drops.length; i++) {
            const text = chars[Math.floor(Math.random() * chars.length)];
            ctx.fillText(text, i * 10, drops[i] * 10);
            drops[i]++;
            if (drops[i] * 10 > canvas.height || Math.random() > 0.975) drops[i] = 0;
          }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        setInterval(() => {
          drawMatrix();
          texture.needsUpdate = true;
        }, 60); // plus lent

        // Génération des bâtiments
        for (let x = -size; x <= size; x += spacing) {
          for (let z = -size; z <= size; z += spacing) {
            // Vide en croix
            if (Math.abs(x) < spacing * 2 && z === 0) continue;
            if (Math.abs(z) < spacing * 2 && x === 0) continue;

            const h = Math.random() * 20 + 10;

            const building = document.createElement('a-entity');
            building.setAttribute('position', `${x} 0 ${z}`);

            // Bâtiment principal
            const box = document.createElement('a-box');
            box.setAttribute('width', '4');
            box.setAttribute('depth', '4');
            box.setAttribute('height', h.toFixed(2));
            box.setAttribute('color', '#00ffff');
            box.setAttribute('opacity', '0.4');
            box.setAttribute('material', 'emissive: #00ffff; emissiveIntensity: 0.5;');
            box.setAttribute('position', `0 ${h / 2} 0`);

            // Animation montée-descente infinie
            box.setAttribute('animation__move', {
              property: 'position',
              dir: 'alternate',
              dur: 8000,
              loop: true,
              easing: 'easeInOutSine',
              to: `0 ${h} 0`,
              from: `0 0 0`
            });

            building.appendChild(box);

            // Faces binaires
            const faces = [
              { pos: `0 ${h / 2} 2.01`, rot: '0 0 0' },
              { pos: `0 ${h / 2} -2.01`, rot: '0 180 0' },
              { pos: `2.01 ${h / 2} 0`, rot: '0 -90 0' },
              { pos: `-2.01 ${h / 2} 0`, rot: '0 90 0' }
            ];

            faces.forEach(face => {
              const panel = document.createElement('a-plane');
              panel.setAttribute('position', face.pos);
              panel.setAttribute('rotation', face.rot);
              panel.setAttribute('width', '4');
              panel.setAttribute('height', h.toFixed(2));
              panel.setAttribute('material', 'shader: flat; side: double;');
              panel.addEventListener('loaded', () => {
                const mesh = panel.getObject3D('mesh');
                mesh.material.map = texture;
                mesh.material.needsUpdate = true;
              });

              // Animation synchronisée avec le cube
              panel.setAttribute('animation__move', {
                property: 'position',
                dir: 'alternate',
                dur: 8000,
                loop: true,
                easing: 'easeInOutSine',
                to: `${face.pos.split(' ')[0]} ${parseFloat(face.pos.split(' ')[1]) + (h / 2)} ${face.pos.split(' ')[2]}`,
                from: `${face.pos}`
              });

              building.appendChild(panel);
            });

            container.appendChild(building);
          }
        }
      }
    });
  </script>

</a-scene>

</body>
</html>
