<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Big Data Digital City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <style> 
    body { 
      margin: 0; 
      overflow: hidden; 
      background: black; 
      font-family: Arial, sans-serif;
    } 
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #00ffff;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #00ffff;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      font-size: 14px;
    }
  </style>
</head>
<body>



<div id="controls">
  <div>üéÆ WASD - Se d√©placer</div>
  <div>üñ±Ô∏è Souris - Regarder autour</div>
  <div>üì± Mobile - Touch controls</div>
</div>

<a-scene background="color: #000" loading-screen="enabled: false">

  <!-- Cam√©ra avec contr√¥les activ√©s -->
  <a-entity id="cameraRig" position="0 5 8">
    <a-entity 
      camera 
      look-controls="pointerLockEnabled: true" 
      wasd-controls="acceleration: 15; fly: true"
      position="0 0 0">
    </a-entity>
  </a-entity>

  <!-- Lumi√®res optimis√©es -->
  <a-entity light="type: ambient; color: #002244; intensity: 0.3"></a-entity>
  <a-entity light="type: directional; color: #00ffff; intensity: 0.8" position="20 30 20"></a-entity>
  <a-entity light="type: point; color: #ff0066; intensity: 0.5" position="-20 15 -20"></a-entity>

  <!-- Sol r√©fl√©chissant -->
  <a-plane 
    position="0 -0.5 0" 
    rotation="-90 0 0" 
    width="120" 
    height="120" 
    color="#001122" 
    material="metalness: 0.8; roughness: 0.2; opacity: 0.3"
    shadow="receive: true">
  </a-plane>

  <!-- Ville dynamique -->
  <a-entity id="city" generate-city></a-entity>

  <!-- Particules flottantes -->
  <a-entity particle-system="preset: dust; particleCount: 200; color: #00ffff,#ff0066; size: 0.5"></a-entity>

  <script>
    // Gestion du loading - correction imm√©diate
    window.addEventListener('load', function() {
      // Masquer imm√©diatement l'√©cran de chargement
      const loadingScreen = document.getElementById('loading');
      const controls = document.getElementById('controls');
      
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
      if (controls) {
        controls.style.opacity = '1';
      }
    });

    // Backup au cas o√π
    setTimeout(() => {
      const loadingScreen = document.getElementById('loading');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }, 1000);

    AFRAME.registerComponent('generate-city', {
      init: function () {
        const container = this.el;
        const spacing = 12;
        const gridSize = 8; // R√©duit pour de meilleures performances
        let textureCache = null;

        // G√©n√©ration optimis√©e de la texture Matrix
        const createMatrixTexture = () => {
          if (textureCache) return textureCache;
          
          const canvas = document.createElement('canvas');
          canvas.width = 128; // R√©duit pour les performances
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          
          // Caract√®res Matrix
          const chars = '„Ç¢„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É©„ÉØ0123456789ABCDEF';
          const fontSize = 8;
          const columns = Math.floor(canvas.width / fontSize);
          const drops = Array(columns).fill(1);

          let frameCount = 0;
          
          const animateMatrix = () => {
            // Animation plus lente pour de meilleures performances
            if (frameCount % 3 !== 0) {
              frameCount++;
              requestAnimationFrame(animateMatrix);
              return;
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ffff';
            ctx.font = `${fontSize}px monospace`;
            
            for (let i = 0; i < drops.length; i++) {
              const char = chars[Math.floor(Math.random() * chars.length)];
              const x = i * fontSize;
              const y = drops[i] * fontSize;
              
              ctx.fillText(char, x, y);
              
              if (y > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
              }
              drops[i]++;
            }
            
            textureCache.needsUpdate = true;
            frameCount++;
            requestAnimationFrame(animateMatrix);
          };

          textureCache = new THREE.CanvasTexture(canvas);
          textureCache.wrapS = THREE.RepeatWrapping;
          textureCache.wrapT = THREE.RepeatWrapping;
          textureCache.repeat.set(1, 2);
          
          animateMatrix();
          return textureCache;
        };

        const matrixTexture = createMatrixTexture();

        // G√©n√©ration des b√¢timents avec de meilleures performances
        const spacing = 8; // Espacement r√©duit pour plus de proximit√©
        const gridSize = 6; // Grille plus compacte
        const buildingCount = gridSize * gridSize - 8;
        let loadedBuildings = 0;

        for (let x = -gridSize; x <= gridSize; x += 2) {
          for (let z = -gridSize; z <= gridSize; z += 2) {
            // Cr√©ation d'espaces vides pour la navigation
            if (Math.abs(x) <= 1 && Math.abs(z) <= 1) continue;
            
            const posX = x * spacing;
            const posZ = z * spacing;
            const height = Math.random() * 20 + 6;
            const buildingId = `building_${x}_${z}`;

            this.createBuilding(container, posX, posZ, height, matrixTexture, buildingId);
            loadedBuildings++;
          }
        }

        console.log(`Ville g√©n√©r√©e: ${loadedBuildings} b√¢timents`);
      },

      createBuilding: function(container, x, z, height, texture, id) {
        const building = document.createElement('a-entity');
        building.setAttribute('id', id);
        building.setAttribute('position', `${x} 0 ${z}`);

        // Animation synchronis√©e - m√™me dur√©e et phase pour tout le b√¢timent
        const animationDuration = 4000 + (Math.abs(x + z) % 3) * 1000; // Varie selon position
        const baseY = 0.5; // Position de base
        const floatHeight = height * 0.15; // Hauteur de flottement r√©duite

        // Structure principale plus d√©taill√©e
        const mainBox = document.createElement('a-box');
        mainBox.setAttribute('width', '4');
        mainBox.setAttribute('depth', '4');
        mainBox.setAttribute('height', height.toFixed(2));
        mainBox.setAttribute('position', `0 ${height/2 + baseY} 0`);
        mainBox.setAttribute('material', {
          color: '#00ffff',
          opacity: 0.6,
          transparent: true,
          emissive: '#002244',
          emissiveIntensity: 0.3,
          metalness: 0.7,
          roughness: 0.3
        });
        mainBox.setAttribute('shadow', 'cast: true; receive: true');

        // Animation verticale synchronis√©e
        mainBox.setAttribute('animation__float', {
          property: 'position',
          to: `0 ${height/2 + baseY + floatHeight} 0`,
          from: `0 ${height/2 + baseY - floatHeight} 0`,
          dir: 'alternate',
          dur: animationDuration,
          loop: true,
          easing: 'easeInOutSine'
        });

        building.appendChild(mainBox);

        // Panneaux Matrix sur les faces - PARFAITEMENT SYNCHRONIS√âS
        const faces = [
          { pos: [0, height/2 + baseY, 2.1], rot: [0, 0, 0] },
          { pos: [0, height/2 + baseY, -2.1], rot: [0, 180, 0] },
          { pos: [2.1, height/2 + baseY, 0], rot: [0, -90, 0] },
          { pos: [-2.1, height/2 + baseY, 0], rot: [0, 90, 0] }
        ];

        faces.forEach((face, index) => {
          const panel = document.createElement('a-plane');
          panel.setAttribute('width', '4');
          panel.setAttribute('height', height.toFixed(2));
          panel.setAttribute('position', `${face.pos[0]} ${face.pos[1]} ${face.pos[2]}`);
          panel.setAttribute('rotation', `${face.rot[0]} ${face.rot[1]} ${face.rot[2]}`);
          panel.setAttribute('material', {
            shader: 'flat',
            side: 'double',
            transparent: true,
            opacity: 0.9
          });

          // Animation EXACTEMENT synchronis√©e avec le b√¢timent principal
          panel.setAttribute('animation__float', {
            property: 'position',
            to: `${face.pos[0]} ${face.pos[1] + floatHeight} ${face.pos[2]}`,
            from: `${face.pos[0]} ${face.pos[1] - floatHeight} ${face.pos[2]}`,
            dir: 'alternate',
            dur: animationDuration, // M√äME dur√©e exacte
            loop: true,
            easing: 'easeInOutSine' // M√äME easing exacte
          });

          panel.addEventListener('loaded', () => {
            const mesh = panel.getObject3D('mesh');
            if (mesh && mesh.material) {
              mesh.material.map = texture;
              mesh.material.needsUpdate = true;
            }
          });

          building.appendChild(panel);
        });

        // Antenne sur le toit - aussi synchronis√©e
        if (Math.random() > 0.6) {
          const antenna = document.createElement('a-cylinder');
          antenna.setAttribute('radius', '0.1');
          antenna.setAttribute('height', '2');
          antenna.setAttribute('position', `0 ${height + baseY + 1} 0`);
          antenna.setAttribute('color', '#ff0066');
          antenna.setAttribute('material', 'emissive: #ff0066; emissiveIntensity: 0.7');
          
          // Animation parfaitement synchronis√©e
          antenna.setAttribute('animation__float', {
            property: 'position',
            to: `0 ${height + baseY + 1 + floatHeight} 0`,
            from: `0 ${height + baseY + 1 - floatHeight} 0`,
            dir: 'alternate',
            dur: animationDuration, // M√äME dur√©e
            loop: true,
            easing: 'easeInOutSine' // M√äME easing
          });

          building.appendChild(antenna);
        }

        container.appendChild(building);
      }
    });

    // Gestion des performances
    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', function () {
      console.log('Sc√®ne 3D charg√©e avec succ√®s!');
      
      // Optimisation du rendu
      scene.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      scene.renderer.shadowMap.enabled = true;
      scene.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    });

    // Gestion responsive
    window.addEventListener('resize', function() {
      const scene = document.querySelector('a-scene');
      if (scene.renderer) {
        scene.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>

</a-scene>

</body>
</html>
