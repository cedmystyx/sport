<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Big Data Digital City - Version Améliorée</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Chargement différé des bibliothèques nécessaires -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/EffectComposer.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/RenderPass.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/ShaderPass.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/FilmShader.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/CopyShader.js" defer></script>

  <style>
    /* Styles globaux */
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    /* Overlay binaire en superposition */
    .binary {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.2;
      color: #0ff;
      opacity: 0.08;
      pointer-events: none;
      white-space: pre;
      animation: scroll 15s linear infinite;
      z-index: 5;
    }
    @keyframes scroll {
      0%   { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }
  </style>
</head>
<body>
  <!-- Overlay binaire dynamique -->
  <div class="binary">
    0101010010101010101001010010101010100101010010101010100101010101<br>
    1010010101010010101010101001010101001010100101010101010010101010<br>
    0101010100101010101001010101010101010010101010010101010100101010<br>
  </div>

  <!-- Audio d'ambiance futuriste avec fallback pour navigateurs non compatibles -->
  <audio autoplay loop>
    <source src="https://cdn.pixabay.com/audio/2023/03/07/audio_eb50a9b332.mp3" type="audio/mpeg">
    Votre navigateur ne supporte pas la lecture audio.
  </audio>

  <!-- Scène A-Frame principale -->
  <a-scene background="color: #000" embedded postprocess="enabled: true">
    <!-- Caméra avec animation pré-définie (survol de la ville) -->
    <a-entity id="cameraRig" position="0 2 30"
              animation="property: position; to: 0 2 -500; dur: 30000; easing: linear; loop: true">
      <a-entity camera look-controls="enabled: false"></a-entity>
    </a-entity>

    <!-- Éclairage de la scène -->
    <a-entity light="type: ambient; color: #0ff; intensity: 0.3"></a-entity>
    <a-entity light="type: directional; color: #0ff; intensity: 0.7" position="0 20 10"></a-entity>

    <!-- Sol animé avec shader personnalisé pour l'effet grille futuriste -->
    <a-entity geometry="primitive: plane; width: 300; height: 1000"
              rotation="-90 0 0"
              material="shader: custom-grid"></a-entity>

    <!-- Conteneur pour la génération de la ville -->
    <a-entity id="city" generate-city></a-entity>

    <!-- Composants et shaders personnalisés -->
    <script>
      // Composant pour générer dynamiquement la ville
      AFRAME.registerComponent('generate-city', {
        schema: {
          count: { type: 'int', default: 800 }  // Nombre de bâtiments générés (modifiable)
        },
        init: function () {
          const container = this.el;
          const count = this.data.count;
          for (let i = 0; i < count; i++) {
            const box = document.createElement('a-box');
            const x = (Math.random() - 0.5) * 100;
            // Génération de la profondeur pour créer un effet de perspective non linéaire
            const z = -Math.pow(i, 1.02) * 3 - 20;
            const h = Math.random() * 20 + 2;
            box.setAttribute('position', `${x} ${h / 2} ${z.toFixed(2)}`);
            box.setAttribute('width', (2 + Math.random() * 2).toFixed(2));
            box.setAttribute('depth', (2 + Math.random() * 2).toFixed(2));
            box.setAttribute('height', h.toFixed(2));
            box.setAttribute('color', '#0ff');
            box.setAttribute('opacity', 0.5);
            // Possibilité d'ajouter des animations ou interactions sur chaque bâtiment
            container.appendChild(box);
          }
        }
      });

      // Shader personnalisé pour le sol (effet grille avec animation)
      AFRAME.registerShader('custom-grid', {
        schema: { timeMsec: { type: 'time', is: 'uniform' } },
        vertexShader: `
          varying vec2 vUV;
          void main() {
            vUV = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float timeMsec;
          varying vec2 vUV;
          void main() {
            float t = timeMsec / 1000.0;
            // Lignes verticales statiques
            float gx = step(0.015, abs(mod(vUV.x * 80.0, 1.0) - 0.5));
            // Lignes horizontales animées
            float gy = step(0.015, abs(mod(vUV.y * 200.0 + t * 5.0, 1.0) - 0.5));
            float g = max(gx, gy);
            vec3 color = mix(vec3(0.0), vec3(0.0, 1.0, 1.0), g);
            gl_FragColor = vec4(color, 0.3);
          }
        `
      });

      // Système de post-traitement pour appliquer un effet « film »
      AFRAME.registerSystem('postprocess', {
        init: function () {
          const sceneEl = this.el;
          const renderer = sceneEl.renderer;
          const scene = sceneEl.object3D;
          const camera = sceneEl.camera;
          // Mise en place de l'EffectComposer pour gérer les passes
          const composer = new THREE.EffectComposer(renderer);
          composer.addPass(new THREE.RenderPass(scene, camera));
          // Application d’une passe film pour le bruit et les scanlines
          const filmPass = new THREE.ShaderPass(THREE.FilmShader);
          filmPass.uniforms['nIntensity'].value = 0.4;  // Intensité du grain
          filmPass.uniforms['sIntensity'].value = 0.08; // Intensité des scanlines
          composer.addPass(filmPass);
          this.composer = composer;
          renderer.autoClear = false;
        },
        tick: function () {
          this.el.renderer.clear();
          this.composer.render();
        }
      });
    </script>
  </a-scene>
</body>
</html>
